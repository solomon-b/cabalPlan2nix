# cabalPlan2nix: Generate Nix derivations from Cabal plan.json files
#
# This function takes a plan.json file generated by cabal and produces
# a Haskell package set overlay compatible with nixpkgs.
#
# Arguments:
#   lib: nixpkgs lib
#   callHackage: haskellPackages.callHackage
#   callCabal2nix: haskellPackages.callCabal2nix
#
# Returns a function that takes:
#   planJsonPath: Path to the plan.json file
#
# And returns a Haskell package set overlay

{ lib, haskell, callPackage }:

let
  # Import helper functions
  helpers = callPackage ./helpers.nix { };
  inherit (helpers) parsePlanJson makeRelativePath;

  # GHC boot packages that should never be overridden to prevent infinite recursion
  # Based on stacklock2nix's approach - these are core GHC libraries that cause
  # dependency cycles if overridden
  ghcBootPackages = [
    "array" "base" "binary" "bytestring" "Cabal" "containers" "deepseq"
    "directory" "exceptions" "filepath" "ghc-bignum" "ghc-boot" "ghc-boot-th"
    "ghc-compact" "ghc-heap" "ghc-internal" "ghc-prim" "ghci" "haskeline"
    "hpc" "integer-gmp" "libiserv" "mtl" "os-string" "parsec" "pretty"
    "process" "rts" "stm" "template-haskell" "terminfo" "text" "time"
    "transformers" "unix" "xhtml"
  ];

  cabal2nixArgsForPkg = callPackage ./cabal2nixArgsForPkg.nix {};

  getAdditionalCabal2nixArgs = pkgName: pkgVersion:
    if builtins.hasAttr pkgName cabal2nixArgsForPkg then
      (builtins.getAttr pkgName cabal2nixArgsForPkg) pkgVersion
    else
      {};

  # Create the overlay function for a given plan.json
  createOverlay = planJsonPath: baseDir:
    let
      packageInfos = parsePlanJson planJsonPath;
    in
      # Return an overlay function that creates a completely fresh package set
      hself: hsuper:
        let
          # Create fresh packages for all dependencies from plan.json
          planPackages = lib.listToAttrs (
            map (pkgInfo:
              let
                pname = pkgInfo.name;
                version = pkgInfo.version;
                isBootPackage = builtins.elem pname ghcBootPackages;
                psrc = pkgInfo.src;
              in
                if pkgInfo.isLocal then
                  # Use callCabal2nix for local packages with relative path
                  { name = pname;
                    value =
                      let
                        mkrel = makeRelativePath baseDir psrc.path;
                        pth = builtins.dirOf planJsonPath + ("/" + mkrel);
                      in hself.callCabal2nix pname pth {};
                  }
                else if pkgInfo.isFromHackage then
                  # Use exact version from plan.json for Hackage packages
                  { name = pname;
                    value =
                      let
                        cabal2nixArgs = getAdditionalCabal2nixArgs pname version;
                      in
                      # TODO: Marking everything dontCheck works around a bunch of the
                      # cyclic dep issues.
                      #
                      # But really, everything shouldn't be marked dontCheck.
                      haskell.lib.compose.dontCheck
                        (hself.callHackage pname version cabal2nixArgs);
                  }
                else if isBootPackage then
                  # Keep GHC boot packages from base set - these are essential
                  { name = pname; value = hsuper.${pname}; }
                else
                  # Keep other packages from base set
                  { name = pname; value = hsuper.${pname} or null; }
            ) packageInfos
          );

          # Add essential GHC boot packages that might not be in plan.json but are needed
          # for other packages to build properly - only add ones that exist in hsuper
          essentialBootPackages = lib.listToAttrs (
            map (bootPkg: {
              name = bootPkg;
              value = hsuper.${bootPkg} or null;
            }) ghcBootPackages
          );
        in
          # Merge plan packages with essential boot packages
          # Plan packages take precedence over boot packages if both are present
          essentialBootPackages // planPackages;


  # Main cabalPlan2nix function - returns an object with overridePackageSet method
  cabalPlan2nix = planJsonPath: baseDir:
    {
      # Expose the overlay function for direct use
      overlay = createOverlay planJsonPath baseDir;
    };

in
  cabalPlan2nix
