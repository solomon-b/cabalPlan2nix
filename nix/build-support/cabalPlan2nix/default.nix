# cabalPlan2nix: Generate Nix derivations from Cabal plan.json files
#
# This function takes a plan.json file generated by cabal and produces
# a Haskell package set overlay compatible with nixpkgs.
#
# Arguments:
#   lib: nixpkgs lib
#   callHackage: haskellPackages.callHackage
#   callCabal2nix: haskellPackages.callCabal2nix
#
# Returns a function that takes:
#   planJsonPath: Path to the plan.json file
#
# And returns a Haskell package set overlay

{ lib, haskell, callPackage }:

let
  # Import helper functions
  helpers = callPackage ./helpers.nix { };
  inherit (helpers) parsePlanJson makeRelativePath;

  # GHC boot packages that should never be overridden to prevent infinite recursion
  # Based on stacklock2nix's approach - these are core GHC libraries that cause
  # dependency cycles if overridden
  ghcBootPackages = [
    "array" "base" "binary" "bytestring" "Cabal" "containers" "deepseq"
    "directory" "exceptions" "filepath" "ghc-bignum" "ghc-boot" "ghc-boot-th"
    "ghc-compact" "ghc-heap" "ghc-internal" "ghc-prim" "ghci" "haskeline"
    "hpc" "integer-gmp" "libiserv" "mtl" "os-string" "parsec" "pretty"
    "process" "rts" "stm" "template-haskell" "terminfo" "text" "time"
    "transformers" "unix" "xhtml"
  ];

  cabal2nixArgsForPkg = callPackage ./cabal2nixArgsForPkg.nix {};

  getAdditionalCabal2nixArgs = pkgName: pkgVersion:
    if builtins.hasAttr pkgName cabal2nixArgsForPkg then
      (builtins.getAttr pkgName cabal2nixArgsForPkg) pkgVersion
    else
      {};


  # Create the overlay function for a given plan.json
  createOverlay = planJsonPath: baseDir: cab2nixOutCache:
    let
      packageInfos = planJsonPath: parsePlanJson planJsonPath;
    in
      # Return an overlay function that creates a completely fresh package set
      hself: hsuper:
        let
          # Create fresh packages for all dependencies from plan.json
          planPackages = lib.listToAttrs (
            map (pkgInfo:
              let
                pname = pkgInfo.name;
                version = pkgInfo.version;
                isBootPackage = builtins.elem pname ghcBootPackages;
                psrc = pkgInfo.src;
              in
                if pkgInfo.isLocal then
                  # Use callCabal2nix for local packages with relative path
                  { name = pname;
                    value =
                      let
                        mkrel = makeRelativePath baseDir psrc.path;
                        pth = builtins.dirOf planJsonPath + ("/" + mkrel);
                      in hself.callCabal2nix pname pth {};
                  }
                else if pkgInfo.isFromHackage then
                  # Use exact version from plan.json for Hackage packages
                  { name = pname;
                    value =
                      let
                        cabal2nixArgs = getAdditionalCabal2nixArgs pname version;
                      in
                      # TODO: Marking everything dontCheck works around a bunch of the
                      # cyclic dep issues.
                      #
                      # But really, everything shouldn't be marked dontCheck.
                      haskell.lib.compose.dontCheck
                        # (hself.callHackage pname version cabal2nixArgs);
                        (hself.callPackage "${cab2nixOutCache}/${pname}-${version}.nix" cabal2nixArgs);
                  }
                else if isBootPackage then
                  # Keep GHC boot packages from base set - these are essential
                  { name = pname; value = hsuper.${pname}; }
                else
                  # Keep other packages from base set
                  # TODO: We should actually be handling this case
                  { name = pname; value = hsuper.${pname} or null; }
            ) packageInfos
          );

          # Add essential GHC boot packages that might not be in plan.json but are needed
          # for other packages to build properly - only add ones that exist in hsuper
          essentialBootPackages = lib.listToAttrs (
            map (bootPkg: {
              name = bootPkg;
              value = hsuper.${bootPkg} or null;
            }) ghcBootPackages
          );
        in
          # Merge plan packages with essential boot packages
          # Plan packages take precedence over boot packages if both are present
          essentialBootPackages // planPackages;

  cabal2nixOutputCacheComputed = planJsonPath: hself:
    let
      packageInfos = parsePlanJson planJsonPath;

      pkgToCab2nixOutput =
        pkgInfo:
          if !pkgInfo.isLocal && pkgInfo.isFromHackage then
            { name = pkgInfo.name;
            , version = pkgsInfo.version;
              cabal2nixOutput =
                let
                  cabal2nixArgs = getAdditionalCabal2nixArgs pkgInfo.name pkgInfo.version;
                in
                  # (hself.callHackage pkgInfo.name pkgInfo.version cabal2nixArgs);
                  # (hself.haskellSrc2nix "${cab2nixOutCache}/${pkgInfo.name}-${pkgInfo.version}.nix" cabal2nixArgs);
                  hself.haskellSrc2nix { name = pkgInfo.name; src = pkgInfo.src; };
            }
          else null;

      hackagePackagesCab2nixOutput = builtins.filter (p: p != null) (map pkgToCab2nixOutput packageInfos);
    in
      runCommand "testtesttest" {}
        ''
          mkdir -p "$out"
        '' +
        (lib.concatMapStrings
          ({name, version, cabal2nixOutput}: ''
            cp "${cabal2nixOutput}/default.nix" "$out/${name}-${version}.nix"
          '')
          hackagePackagesCab2nixOutput
        );

  # Main cabalPlan2nix function - returns an object with overridePackageSet method
  cabalPlan2nix = planJsonPath: baseDir:
    {
      # Expose the overlay function for direct use
      overlay =
        createOverlay
          planJsonPath
          baseDir
          (if cabal2nixOutputCache != null then cabal2nixOutputCache else cabal2nixOutputCacheComputed planJsonPath);

      xxx = cabal2nixOutputCacheComputed planJsonPath hself;
    };

in
  cabalPlan2nix
